#!/usr/bin/env python3
from __future__ import annotations

"""
Compatibility wrapper: `ccb` has been rebranded to `cq`.

This wrapper forwards execution to `cq` while preserving importability for tests
that load the legacy `ccb` script as a module.
"""

import importlib.util
import re
import sys
from importlib.machinery import SourceFileLoader
from pathlib import Path
from types import ModuleType
from typing import Any


_CQ_MODULE: ModuleType | None = None


def _load_cq_module() -> ModuleType:
    global _CQ_MODULE
    if _CQ_MODULE is not None:
        return _CQ_MODULE

    cq_path = Path(__file__).resolve().parent / "cq"
    loader = SourceFileLoader("cq_script", str(cq_path))
    spec = importlib.util.spec_from_loader("cq_script", loader)
    assert spec and spec.loader
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)  # type: ignore[union-attr]
    _CQ_MODULE = module
    return module


def __getattr__(name: str) -> Any:
    return getattr(_load_cq_module(), name)


def __dir__() -> list[str]:
    try:
        return sorted(set(globals().keys()) | set(dir(_load_cq_module())))
    except Exception:
        return sorted(globals().keys())


def _print_version_fast(argv: list[str]) -> bool:
    if "--print-version" not in argv:
        return False
    cq_path = Path(__file__).resolve().parent / "cq"
    try:
        content = cq_path.read_text(encoding="utf-8", errors="replace")
        m = re.search(
            r'^VERSION\s*=\s*["\']([^"\']+)["\']\s*$',
            content,
            flags=re.MULTILINE,
        )
        if m:
            print(f"v{m.group(1)}")
            return True
    except Exception:
        pass
    cq = _load_cq_module()
    print(f"v{getattr(cq, 'VERSION', '')}")
    return True


if __name__ == "__main__":
    if _print_version_fast(sys.argv[1:]):
        sys.exit(0)
    sys.exit(_load_cq_module().main())
