#!/usr/bin/env python3
"""
ccb-mounted - Check which CCB providers are mounted.

A provider is "mounted" if:
1. Session file exists (.ccb_config/.{provider}-session or .{provider}-session) and is active
2. Daemon is responsive (via RPC ping) - OR socket access is blocked (sandbox mode)

Supports both unified askd daemon and legacy per-provider daemons.
Falls back to session-file-only checks in sandboxed environments.

Usage:
    ccb-mounted [CWD] [--json|--simple] [--include-inactive]
"""

import sys
import os
import json
import socket
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

PROVIDERS = ["codex", "claude"]


def find_session_file_path(cwd: Path, provider: str) -> Path | None:
    """Return the provider session file path if present."""
    candidates = (
        cwd / ".ccb_config" / f".{provider}-session",
        cwd / f".{provider}-session",
    )
    for p in candidates:
        if p.exists():
            return p
    return None


def session_file_is_active(path: Path) -> bool:
    """
    Determine whether a provider session file is active.

    Backwards-compatible behavior:
    - If `active` is explicitly `false`, treat it as inactive.
    - If `active` is missing/unparseable, treat it as active.
    """
    try:
        raw = path.read_text(encoding="utf-8-sig", errors="replace")
        data = json.loads(raw)
        if isinstance(data, dict) and data.get("active") is False:
            return False
    except Exception:
        return True
    return True


def can_connect_localhost() -> bool:
    """Test if we can make localhost socket connections (sandbox check)."""
    try:
        # Try to create a socket and connect to a likely-closed port
        # If we get "Operation not permitted", we're in a sandbox
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.1)
        try:
            # Port 1 is almost certainly not listening, so we expect connection refused
            # But if we're sandboxed, we'll get permission denied
            sock.connect(("127.0.0.1", 1))
        except PermissionError:
            # Sandbox detected
            return False
        except (socket.timeout, ConnectionRefusedError, OSError):
            # Normal behavior - we can attempt connections
            return True
        finally:
            sock.close()
    except Exception:
        return True  # Assume we can connect if test fails unexpectedly
    return True


def ping_unified_askd() -> bool:
    """Ping the unified askd daemon."""
    try:
        from askd import daemon as askd_daemon
        return askd_daemon.ping_daemon(timeout_s=0.5)
    except Exception:
        return False


def ping_provider_daemon(provider: str) -> bool:
    """Ping a provider-specific daemon (legacy mode)."""
    daemon_modules = {
        "codex": "caskd_daemon",
        "claude": "laskd_daemon",
    }
    module_name = daemon_modules.get(provider)
    if not module_name:
        return False
    try:
        module = __import__(module_name)
        ping = getattr(module, "ping_daemon", None)
        if ping:
            return ping(timeout_s=0.5)
        return False
    except Exception:
        return False


def main():
    args = sys.argv[1:]

    # Parse arguments
    cwd = Path.cwd()
    fmt = "--json"
    include_inactive = False

    for arg in args:
        if arg.startswith("--"):
            if arg == "--include-inactive":
                include_inactive = True
            else:
                fmt = arg
        else:
            cwd = Path(arg)

    # Check if we're in a sandboxed environment
    sandboxed = not can_connect_localhost()

    # Check if unified askd is running (skip if sandboxed)
    unified_askd_running = False if sandboxed else ping_unified_askd()

    mounted = []

    for provider in PROVIDERS:
        session_file = find_session_file_path(cwd, provider)
        if not session_file:
            continue
        if (not include_inactive) and (not session_file_is_active(session_file)):
            continue

        # Session exists (and is active unless include_inactive is set).
        if sandboxed:
            # In sandbox, trust session + active flag only.
            mounted.append(provider)
            continue

        if unified_askd_running or ping_provider_daemon(provider):
            mounted.append(provider)

    if fmt == "--simple":
        print(" ".join(mounted))
    else:
        result = {"cwd": str(cwd), "mounted": mounted}
        print(json.dumps(result))


if __name__ == "__main__":
    main()
