#!/usr/bin/env python3
"""
CCB Completion Hook - Notifies Claude when a CCB delegation task completes.

This script is called by caskd/gaskd/oaskd/daskd when they detect CCB_DONE signal.
It sends a notification to Claude via lask to trigger auto-retrieval of results.

Usage:
    ccb-completion-hook.py --provider <provider> --output <output_file> [--reply <reply_text>]

Environment:
    CCB_COMPLETION_HOOK_ENABLED: Set to "0" to disable (default: "1")
    CCB_COMPLETION_HOOK_TIMEOUT: Timeout in seconds (default: 5)
    CCB_COMPLETION_HOOK_RESULT_MODE: full|summary|none (default: summary)
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
from pathlib import Path

# Add lib directory to path for imports
script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding

setup_windows_encoding()


def env_bool(name: str, default: bool = True) -> bool:
    val = os.environ.get(name, "").strip().lower()
    if not val:
        return default
    return val not in ("0", "false", "no", "off")


def env_float(name: str, default: float) -> float:
    val = os.environ.get(name, "").strip()
    if not val:
        return default
    try:
        return float(val)
    except ValueError:
        return default


def _result_mode_for_caller(caller: str) -> str:
    """
    Return completion-hook result mode for a given caller.

    Modes:
    - full: include full provider reply in the pasted notification (legacy behavior)
    - summary: omit reply content; user should run `pend <provider>` for full text
    - none: do not send any completion notification

    Defaults:
    - summary (to avoid duplicate output when using `pend`)
    """
    override = os.environ.get("CCB_COMPLETION_HOOK_RESULT_MODE", "").strip().lower()
    if override in ("full", "summary", "none"):
        return override
    return "summary"


def format_completion_message(*, provider_display: str, provider: str, req_id: str, output_file: str | None, reply: str, caller: str) -> str:
    mode = _result_mode_for_caller(caller)
    if mode == "full":
        result_line = f"Result: {reply}\n"
    elif mode == "summary":
        result_line = f"Result: (suppressed; run `pend {provider}`)\n"
    else:
        result_line = ""

    if output_file:
        return (
            f"CCB_REQ_ID: {req_id}\n\n"
            f"[CCB_TASK_COMPLETED]\n"
            f"Provider: {provider_display}\n"
            f"Output file: {output_file}\n\n"
            f"{result_line}"
        )
    return (
        f"CCB_REQ_ID: {req_id}\n\n"
        f"[CCB_TASK_COMPLETED]\n"
        f"Provider: {provider_display}\n\n"
        f"{result_line}"
    )


def load_session_file(session_path: Path) -> dict:
    """Load session file with utf-8-sig encoding (handles BOM from PowerShell)."""
    try:
        with open(session_path, encoding="utf-8-sig") as f:
            return json.load(f)
    except Exception:
        return {}


def send_via_terminal(pane_id: str, message: str, terminal: str, session_data: dict) -> bool:
    """Send message via terminal backend (tmux or wezterm)."""
    if terminal == "wezterm":
        return send_via_wezterm(pane_id, message, session_data)
    else:
        return send_via_tmux(pane_id, message)


def find_wezterm_cli() -> str | None:
    """Find wezterm CLI executable."""
    import shutil
    # Check environment variable first
    wezterm_bin = os.environ.get("CCB_WEZTERM_BIN", "").strip()
    if wezterm_bin and Path(wezterm_bin).exists():
        return wezterm_bin
    # Try shutil.which for PATH lookup
    found = shutil.which("wezterm")
    if found:
        return found
    # Common Windows locations
    if os.name == "nt":
        common_paths = [
            Path(os.environ.get("PROGRAMFILES", "")) / "WezTerm" / "wezterm.exe",
            Path(os.environ.get("LOCALAPPDATA", "")) / "Programs" / "WezTerm" / "wezterm.exe",
            Path.home() / "scoop" / "apps" / "wezterm" / "current" / "wezterm.exe",
        ]
        for p in common_paths:
            if p.exists():
                return str(p)
    return None


def send_via_wezterm(pane_id: str, message: str, session_data: dict) -> bool:
    """Send message to WezTerm pane using wezterm cli with stdin for large payloads."""
    try:
        wezterm = find_wezterm_cli()
        if not wezterm:
            return False

        # Use stdin to avoid command line length limits on Windows
        # wezterm cli send-text --pane-id <id> --no-paste reads from stdin if no text arg
        result = subprocess.run(
            [wezterm, "cli", "send-text", "--pane-id", pane_id, "--no-paste"],
            input=message.encode("utf-8"),
            capture_output=True,
            timeout=10
        )
        if result.returncode == 0:
            # Send Enter after text
            subprocess.run(
                [wezterm, "cli", "send-text", "--pane-id", pane_id, "--no-paste"],
                input=b"\r",
                capture_output=True,
                timeout=5
            )
            return True
    except Exception:
        pass
    return False


def send_via_tmux(pane_id: str, message: str) -> bool:
    """Send message to tmux pane using load-buffer + paste-buffer."""
    try:
        import time

        # Ensure pane is not in copy mode
        try:
            mode_result = subprocess.run(
                ["tmux", "display-message", "-p", "-t", pane_id, "#{pane_in_mode}"],
                capture_output=True,
                text=True,
                timeout=2
            )
            if mode_result.returncode == 0 and mode_result.stdout.strip() in ("1", "on", "yes"):
                subprocess.run(
                    ["tmux", "send-keys", "-t", pane_id, "-X", "cancel"],
                    capture_output=True,
                    timeout=2
                )
        except Exception:
            pass

        buffer_name = f"ccb-hook-{os.getpid()}-{int(time.time() * 1000)}"
        # Load message into tmux buffer
        load_result = subprocess.run(
            ["tmux", "load-buffer", "-b", buffer_name, "-"],
            input=message.encode("utf-8"),
            capture_output=True,
            timeout=5
        )
        if load_result.returncode != 0:
            return False
        try:
            # Paste buffer to pane
            paste_result = subprocess.run(
                ["tmux", "paste-buffer", "-p", "-t", pane_id, "-b", buffer_name],
                capture_output=True,
                timeout=5
            )
            if paste_result.returncode == 0:
                # Send Enter after paste (wait 1s for stability)
                time.sleep(1.0)
                subprocess.run(
                    ["tmux", "send-keys", "-t", pane_id, "Enter"],
                    capture_output=True,
                    timeout=5
                )
                return True
        finally:
            # Clean up buffer
            subprocess.run(
                ["tmux", "delete-buffer", "-b", buffer_name],
                capture_output=True,
                timeout=2
            )
    except Exception:
        pass
    return False


def find_ask_command() -> str | None:
    """Find the ask command in common locations."""
    ask_paths = [
        Path(__file__).resolve().parent / "ask",
        Path.home() / ".local" / "share" / "codex-dual" / "bin" / "ask",
        Path.home() / ".local" / "bin" / "ask",
    ]
    # On Windows, also check LOCALAPPDATA
    if os.name == "nt":
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            ask_paths.insert(0, Path(localappdata) / "codex-dual" / "bin" / "ask")

    for p in ask_paths:
        if p.exists():
            return str(p)
    return None


def main() -> int:
    if not env_bool("CCB_COMPLETION_HOOK_ENABLED", True):
        return 0

    parser = argparse.ArgumentParser(description="CCB Completion Hook")
    parser.add_argument("--provider", required=True, help="Provider name (codex/claude)")
    parser.add_argument("--caller", default="claude", help="Who initiated the request (claude/codex)")
    parser.add_argument("--output", default="", help="Output file path (optional)")
    parser.add_argument("--reply", default="", help="Reply text (optional)")
    parser.add_argument("--req-id", default="", help="Request ID")
    args = parser.parse_args()

    provider = args.provider.lower()
    caller = args.caller.lower()
    output_file = args.output or None

    # Read reply from stdin using cross-platform helper
    reply_content = ""
    if not sys.stdin.isatty():
        reply_content = read_stdin_text()
    if not reply_content:
        reply_content = args.reply or ""

    # Construct notification message
    provider_names = {
        "codex": "Codex",
        "claude": "Claude",
    }
    provider_display = provider_names.get(provider, provider.capitalize())
    req_id = args.req_id or "unknown"

    mode = _result_mode_for_caller(caller)
    if mode == "none":
        return 0

    message = format_completion_message(
        provider_display=provider_display,
        provider=provider,
        req_id=req_id,
        output_file=output_file,
        reply=reply_content,
        caller=caller,
    )

    # Find caller's pane_id from session file
    session_files = {
        "claude": ".claude-session",
        "codex": ".codex-session",
    }
    session_filename = session_files.get(caller, ".claude-session")

    # Search for session file in common locations
    work_dir = os.environ.get("CCB_WORK_DIR", os.getcwd())
    search_paths = [
        Path(work_dir) / ".ccb_config" / session_filename,
        Path.home() / ".local" / "share" / "codex-dual" / ".ccb_config" / session_filename,
    ]
    # On Windows, also check LOCALAPPDATA
    if os.name == "nt":
        localappdata = os.environ.get("LOCALAPPDATA", "")
        if localappdata:
            search_paths.insert(0, Path(localappdata) / "codex-dual" / ".ccb_config" / session_filename)

    pane_id = None
    terminal = "tmux"  # default
    session_data = {}

    for session_path in search_paths:
        if session_path.exists():
            session_data = load_session_file(session_path)
            pane_id = session_data.get("pane_id")
            terminal = session_data.get("terminal", "tmux")
            if pane_id:
                break

    if not pane_id:
        # No pane_id found, try ask command
        timeout = env_float("CCB_COMPLETION_HOOK_TIMEOUT", 10.0)
        ask_cmd = find_ask_command()
        if not ask_cmd:
            return 0
        try:
            # Use sys.executable to run ask command on Windows
            if os.name == "nt":
                result = subprocess.run(
                    [sys.executable, ask_cmd, caller, "--notify", "--no-wrap", message],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
            else:
                result = subprocess.run(
                    [ask_cmd, caller, "--notify", "--no-wrap", message],
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
            return result.returncode
        except Exception:
            return 0

    # Send directly via terminal backend
    if send_via_terminal(pane_id, message, terminal, session_data):
        return 0

    # Fallback to ask command if terminal send failed
    timeout = env_float("CCB_COMPLETION_HOOK_TIMEOUT", 10.0)
    ask_cmd = find_ask_command()
    if not ask_cmd:
        return 0
    try:
        if os.name == "nt":
            subprocess.run(
                [sys.executable, ask_cmd, caller, "--notify", "--no-wrap", message],
                capture_output=True,
                text=True,
                timeout=timeout
            )
        else:
            subprocess.run(
                [ask_cmd, caller, "--notify", "--no-wrap", message],
                capture_output=True,
                text=True,
                timeout=timeout
            )
    except Exception:
        pass
    return 0


if __name__ == "__main__":
    sys.exit(main())
