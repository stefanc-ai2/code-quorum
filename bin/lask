#!/usr/bin/env python3
"""
lask - Send message to Claude and wait for reply (sync).

Designed to be used with Codex/OpenCode in background mode.
If --output is provided, the reply is written atomically to that file and stdout stays empty.
"""

from __future__ import annotations

import os
import sys
from pathlib import Path
from typing import Optional, Tuple

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding

setup_windows_encoding()

from cli_output import EXIT_ERROR, atomic_write_text
from env_utils import env_bool
from askd_client import (
    state_file_from_env,
    find_project_session_file,
    resolve_work_dir_with_registry,
    try_daemon_request,
    maybe_start_daemon,
    wait_for_daemon_ready,
)
from providers import LASK_CLIENT_SPEC
from claude_session_resolver import resolve_claude_session
from terminal import get_backend_for_session, get_pane_id_from_session
from laskd_protocol import wrap_claude_prompt, make_req_id


ASYNC_GUARDRAIL = """[CCB_ASYNC_SUBMITTED provider=claude]
IMPORTANT: Task submitted to Claude. You MUST:
1. Tell user "Claude processing..."
2. END YOUR TURN IMMEDIATELY
3. Do NOT wait, poll, check status, or use any more tools
"""


def _usage() -> None:
    print("Usage: lask [--async] [--sync] [--no-wrap] [--session-file FILE] [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)


def _parse_args(argv: list[str]) -> Tuple[Optional[Path], float, str, bool, Optional[str], bool, bool, bool]:
    output: Optional[Path] = None
    timeout: Optional[float] = None
    quiet = False
    async_mode = False
    sync_mode = False
    no_wrap = False
    session_file: Optional[str] = None
    parts: list[str] = []

    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            raise SystemExit(0)
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token == "--async":
            async_mode = True
            continue
        if token == "--sync":
            sync_mode = True
            continue
        if token == "--no-wrap":
            no_wrap = True
            continue
        if token == "--session-file":
            try:
                session_file = next(it)
            except StopIteration:
                raise ValueError("--session-file requires a file path")
            continue
        if token in ("-o", "--output"):
            try:
                output = Path(next(it)).expanduser()
            except StopIteration:
                raise ValueError("--output requires a file path")
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                raise ValueError("--timeout requires a number")
            except ValueError as exc:
                raise ValueError(f"Invalid --timeout: {exc}")
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "-1"))
        except Exception:
            timeout = -1.0
    if async_mode:
        timeout = 0.0
    return output, timeout, message, quiet, session_file, async_mode, sync_mode, no_wrap


def main(argv: list[str]) -> int:
    try:
        output_path, timeout, message, quiet, session_file, async_mode, sync_mode, no_wrap = _parse_args(argv)
        if not message and not sys.stdin.isatty():
            message = read_stdin_text().strip()
        if not message:
            _usage()
            return EXIT_ERROR
        if async_mode:
            sync_mode = False

        # Set no_wrap flag via environment variable
        if no_wrap:
            os.environ["CCB_NO_WRAP"] = "1"

        work_dir, _ = resolve_work_dir_with_registry(
            LASK_CLIENT_SPEC,
            provider="claude",
            cli_session_file=session_file,
            env_session_file=os.environ.get("CCB_SESSION_FILE"),
        )

        state_file = state_file_from_env(LASK_CLIENT_SPEC.state_file_env)
        daemon_result = try_daemon_request(LASK_CLIENT_SPEC, work_dir, message, timeout, quiet, state_file, output_path=output_path)
        if daemon_result is None and maybe_start_daemon(LASK_CLIENT_SPEC, work_dir):
            wait_for_daemon_ready(LASK_CLIENT_SPEC, timeout_s=min(2.0, max(0.2, float(timeout))), state_file=state_file)
            daemon_result = try_daemon_request(LASK_CLIENT_SPEC, work_dir, message, timeout, quiet, state_file, output_path=output_path)

        if daemon_result is not None:
            reply, exit_code = daemon_result
            if not sync_mode:
                print(ASYNC_GUARDRAIL, file=sys.stderr, flush=True)
            if output_path:
                atomic_write_text(output_path, reply + "\n")
                return exit_code
            sys.stdout.write(reply)
            if not reply.endswith("\n"):
                sys.stdout.write("\n")
            return exit_code

        # Fallback: send directly to Claude pane (works for both sync and async)
        resolution = resolve_claude_session(work_dir)
        if resolution and resolution.data:
            data = dict(resolution.data)
            if data.get("claude_pane_id") and not data.get("pane_id"):
                data["pane_id"] = data.get("claude_pane_id")
            backend = get_backend_for_session(data) if data else None
            pane_id = get_pane_id_from_session(data) if data else ""
            if backend and pane_id:
                # Apply context injection in fallback path (same as daemon path)
                if not no_wrap:
                    req_id = os.environ.get("CCB_REQ_ID") or make_req_id()
                    message = wrap_claude_prompt(message, req_id)
                backend.send_text(pane_id, message)
                if not sync_mode:
                    print(ASYNC_GUARDRAIL, file=sys.stderr, flush=True)
                return 0

        if not env_bool(LASK_CLIENT_SPEC.enabled_env, True):
            print(f"[ERROR] {LASK_CLIENT_SPEC.enabled_env}=0: lask daemon mode disabled.", file=sys.stderr)
            return EXIT_ERROR
        if not find_project_session_file(work_dir, LASK_CLIENT_SPEC.session_filename):
            print("[ERROR] No active Claude session found for this directory.", file=sys.stderr)
            print("Run `ccb claude` (or add claude to ccb.config) in this project first.", file=sys.stderr)
            return EXIT_ERROR
        print("[ERROR] lask daemon required but not available.", file=sys.stderr)
        print("Start it with `laskd` (or enable autostart via CCB_LASKD_AUTOSTART=1).", file=sys.stderr)
        return EXIT_ERROR
    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        print(f"[ERROR] {exc}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
