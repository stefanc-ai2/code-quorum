#!/usr/bin/env python3
"""
gask-w - Send message to Gemini and wait for reply (pure sync mode)
Designed to be run with Claude Code's run_in_background=true
"""
from __future__ import annotations
import os
import sys
from pathlib import Path
import json

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        print("Usage: gask-w <message>", file=sys.stderr)
        return 1

    message = " ".join(argv[1:]).strip()
    if not message:
        print("‚ùå Message cannot be empty", file=sys.stderr)
        return 1

    if sys.platform == "win32":
        from compat import setup_windows_encoding
        setup_windows_encoding()

    from gemini_comm import GeminiCommunicator
    from i18n import t

    def save_pending_state(state: dict) -> None:
        session_file = Path.cwd() / ".gemini-session"
        if not session_file.exists():
            return
        try:
            with session_file.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
            data["pending_state"] = {
                "session_path": str(state.get("session_path")) if state.get("session_path") else None,
                "msg_count": int(state.get("msg_count", 0) or 0),
                "mtime": float(state.get("mtime", 0.0) or 0.0),
                "mtime_ns": int(state.get("mtime_ns", 0) or 0),
                "size": int(state.get("size", 0) or 0),
                "last_gemini_id": state.get("last_gemini_id"),
                "last_gemini_hash": state.get("last_gemini_hash"),
            }
            tmp_file = session_file.with_suffix(".tmp")
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, session_file)
        except Exception:
            return

    # Save to cache
    cache_dir = Path.home() / ".cache" / "ccb"
    cache_dir.mkdir(parents=True, exist_ok=True)
    reply_file = cache_dir / "gemini_last_reply.txt"
    # Clear stale cache
    if reply_file.exists():
        try:
            reply_file.unlink()
        except Exception:
            pass

    try:
        comm = GeminiCommunicator(lazy_init=True)

        # Check session health
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            print(f"‚ùå Session error: {status}", file=sys.stderr)
            return 1

        # Send message
        print(f"üîî {t('sending_to', provider='Gemini')}", flush=True)
        marker, state = comm._send_message(message)
        comm._remember_gemini_session(state.get("session_path") or comm.log_reader.current_session_path())

        # Pure sync wait (default 1 hour, configurable via CCB_SYNC_TIMEOUT)
        sync_timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        message_reply, new_state = comm.log_reader.wait_for_message(state, sync_timeout)
        state = new_state or state
        comm._remember_gemini_session(state.get("session_path") or comm.log_reader.current_session_path())

        # Save to cache
        cache_dir = Path.home() / ".cache" / "ccb"
        cache_dir.mkdir(parents=True, exist_ok=True)
        reply_file = cache_dir / "gemini_last_reply.txt"

        if message_reply:
            print(f"ü§ñ {t('reply_from', provider='Gemini')}")
            print(message_reply)
            reply_file.write_text(message_reply, encoding="utf-8")
        else:
            print(f"‚è∞ Timeout after {int(sync_timeout)}s")
            save_pending_state(state)
        return 0

    except KeyboardInterrupt:
        try:
            save_pending_state(locals().get("state", {}) if isinstance(locals().get("state"), dict) else {})
        except Exception:
            pass
        print("‚ùå Interrupted", file=sys.stderr)
        return 130
    except Exception as exc:
        print(f"‚ùå {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
