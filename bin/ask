#!/usr/bin/env python3
"""
ask - Send a message to an AI provider's interactive pane (tmux/WezTerm).

Usage:
    ask <provider> [options] <message>

Providers:
    codex, claude

Behavior:
    - Send-only (always async): prints the generated req_id and exits immediately.
    - Uses the provider session for the current working directory (project isolation).
"""

from __future__ import annotations

import os
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding
setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_OK
from codex_session import load_project_session as load_codex_session
from ccb_protocol import make_req_id, wrap_codex_prompt, wrap_reply_payload
from claude_protocol import wrap_claude_prompt
from claude_session import load_project_session as load_claude_session


def _env_bool(name: str, default: bool = False) -> bool:
    val = (os.environ.get(name) or "").strip().lower()
    if not val:
        return default
    return val not in ("0", "false", "no", "off")


def _default_caller() -> str:
    caller = (os.environ.get("CCB_CALLER") or "").strip()
    if caller:
        return caller
    if _env_bool("CCB_MANAGED", False):
        return "codex"
    if os.environ.get("CODEX_SESSION_ID") or os.environ.get("CODEX_RUNTIME_DIR"):
        return "codex"
    return "claude"


def _resolve_req_id() -> str:
    env_req_id = (os.environ.get("CCB_REQ_ID") or "").strip()
    return env_req_id or make_req_id()


def _usage() -> None:
    print("Usage: ask <provider> [options] <message>", file=sys.stderr)
    print("", file=sys.stderr)
    print("Providers:", file=sys.stderr)
    print("  codex, claude", file=sys.stderr)
    print("", file=sys.stderr)
    print("Options:", file=sys.stderr)
    print("  -h, --help              Show this help message", file=sys.stderr)
    print("  --no-wrap               Don't wrap with CCB protocol markers", file=sys.stderr)
    print("  --reply-to REQ_ID       Send a result/notification payload (implies --no-wrap)", file=sys.stderr)


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        _usage()
        return EXIT_ERROR

    # First argument must be the provider
    provider = argv[1].lower()

    if provider in ("-h", "--help"):
        _usage()
        return EXIT_OK

    if provider not in ("codex", "claude"):
        print(f"[ERROR] Unknown provider: {provider}", file=sys.stderr)
        print("[ERROR] Available: codex, claude", file=sys.stderr)
        return EXIT_ERROR

    # Parse remaining arguments
    no_wrap = False
    reply_to_req_id: str | None = None
    parts: list[str] = []

    it = iter(argv[2:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            return EXIT_OK
        if token.startswith("--reply-to="):
            reply_to_req_id = token.split("=", 1)[1].strip() or None
            continue
        if token == "--reply-to":
            try:
                reply_to_req_id = (next(it) or "").strip() or None
            except StopIteration:
                print("[ERROR] --reply-to requires a req_id", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token == "--no-wrap":
            no_wrap = True
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = read_stdin_text().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    caller = _default_caller()
    req_id = _resolve_req_id()

    if reply_to_req_id:
        no_wrap = True
        outbound = wrap_reply_payload(
            reply_to_req_id=reply_to_req_id,
            from_provider=caller,
            message=message,
        )
    else:
        if no_wrap:
            outbound = (message or "").rstrip() + "\n"
        elif provider == "codex":
            outbound = wrap_codex_prompt(message, req_id)
        else:
            outbound = wrap_claude_prompt(message, req_id)

    work_dir = Path.cwd()
    if provider == "codex":
        session = load_codex_session(work_dir)
    else:
        session = load_claude_session(work_dir)

    if not session:
        print(f"[ERROR] No active {provider} session found for this directory.", file=sys.stderr)
        print(f"[ERROR] Run `ccb {provider}` in this project first.", file=sys.stderr)
        return EXIT_ERROR

    ok, pane_or_err = session.ensure_pane()
    if not ok:
        print(f"[ERROR] Session pane not available: {pane_or_err}", file=sys.stderr)
        return EXIT_ERROR

    backend = session.backend()
    if not backend:
        print("[ERROR] Terminal backend not available", file=sys.stderr)
        return EXIT_ERROR

    backend.send_text(pane_or_err, outbound)
    print(req_id)
    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main(sys.argv))
