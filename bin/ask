#!/usr/bin/env python3
"""
ask - Unified command to send messages to different AI providers.

Usage:
    ask <provider> [options] <message>

Providers:
    codex, claude

Modes:
    Default (async):  Background task with hook callback
    --notify:         Sync send, no wait for reply (for notifications)
    --foreground:     Run in foreground (no nohup/background)
    --background:     Force background mode

Examples:
    ask codex "12+12=?"
    ask claude --notify --no-wrap "Task completed"
"""

from __future__ import annotations

import os
import shlex
import subprocess
import sys
import tempfile
from datetime import datetime
from pathlib import Path
import time

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from compat import read_stdin_text, setup_windows_encoding
setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_OK


# Provider to daemon command mapping
PROVIDER_DAEMONS = {
    "codex": "cask",
    "claude": "lask",
}


def _use_unified_daemon() -> bool:
    """Check if unified askd daemon should be used (default: True)."""
    val = (os.environ.get("CCB_UNIFIED_ASKD") or "").strip().lower()
    if val in ("0", "false", "no", "off"):
        return False
    return True  # Default to unified daemon


def _askd_autostart_enabled() -> bool:
    """
    Whether `ask` should auto-start `askd` when using the unified daemon.

    Default: enabled (CCB_ASKD_AUTOSTART not set, or truthy).
    """
    val = (os.environ.get("CCB_ASKD_AUTOSTART") or "").strip().lower()
    if not val:
        return True
    return val not in ("0", "false", "no", "off")


def _askd_cmd() -> list[str] | None:
    askd_path = script_dir / "askd"
    if askd_path.exists():
        if sys.platform == "win32":
            return [sys.executable, str(askd_path)]
        return [str(askd_path)]
    return None


def _ensure_askd_running(timeout_s: float = 1.5) -> bool:
    import askd_rpc
    from askd_runtime import state_file_path

    state_file = state_file_path("askd.json")
    if askd_rpc.ping_daemon("ask", 0.2, state_file):
        return True

    if not _askd_autostart_enabled():
        return False

    cmd = _askd_cmd()
    if not cmd:
        return False

    env = os.environ.copy()
    env.setdefault("CCB_ASKD_IDLE_TIMEOUT_S", "3600")

    try:
        if os.name == "nt":
            DETACHED_PROCESS = 0x00000008
            CREATE_NO_WINDOW = 0x08000000
            CREATE_NEW_PROCESS_GROUP = 0x00000200
            subprocess.Popen(
                cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                env=env,
                creationflags=DETACHED_PROCESS | CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP,
            )
        else:
            subprocess.Popen(
                cmd,
                stdin=subprocess.DEVNULL,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                env=env,
                start_new_session=True,
            )
    except Exception as e:
        if _env_bool("CCB_DEBUG", False):
            print(f"[DEBUG] askd autostart failed: {e}", file=sys.stderr)
        return False

    raw_startup_timeout = (os.environ.get("CCB_ASKD_STARTUP_TIMEOUT_S") or "").strip()
    if raw_startup_timeout:
        try:
            startup_timeout_s = float(raw_startup_timeout)
        except (TypeError, ValueError):
            startup_timeout_s = timeout_s
    else:
        startup_timeout_s = timeout_s
    deadline = time.time() + max(0.1, startup_timeout_s)
    while time.time() < deadline:
        if askd_rpc.ping_daemon("ask", 0.2, state_file):
            return True
        time.sleep(0.05)
    return False


def _send_via_unified_daemon(
    provider: str,
    message: str,
    timeout: float,
    no_wrap: bool,
    caller: str,
) -> int:
    """Send request via unified askd daemon."""
    import json
    import socket

    from askd_runtime import state_file_path
    import askd_rpc

    state_file = state_file_path("askd.json")
    if not _ensure_askd_running():
        print("[ERROR] Unified askd daemon not running", file=sys.stderr)
        print("[ERROR] Hint: start it with `askd` or run via `ccb` (managed mode).", file=sys.stderr)
        return EXIT_ERROR

    state = askd_rpc.read_state(state_file)
    if not state:
        print("[ERROR] Unified askd daemon state missing/invalid", file=sys.stderr)
        return EXIT_ERROR

    host = state.get("connect_host") or state.get("host") or "127.0.0.1"
    port = int(state.get("port") or 0)
    token = state.get("token") or ""

    if not port:
        print("[ERROR] Invalid askd state", file=sys.stderr)
        return EXIT_ERROR

    req = {
        "type": "ask.request",
        "v": 1,
        "id": make_task_id(),
        "token": token,
        "provider": provider,
        "work_dir": os.getcwd(),
        "timeout_s": timeout,
        "message": message,
        "no_wrap": no_wrap,
        "caller": caller,
    }

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout + 10 if timeout > 0 else 3610)
        sock.connect((host, port))
        sock.sendall((json.dumps(req) + "\n").encode("utf-8"))

        data = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            data += chunk
            if b"\n" in data:
                break

        sock.close()
        resp = json.loads(data.decode("utf-8").strip())
        exit_code = int(resp.get("exit_code") or 0)
        reply = resp.get("reply") or ""
        if reply:
            print(reply)
        return exit_code
    except Exception as e:
        print(f"[ERROR] {e}", file=sys.stderr)
        return EXIT_ERROR


def _env_bool(name: str, default: bool = False) -> bool:
    val = (os.environ.get(name) or "").strip().lower()
    if not val:
        return default
    return val not in ("0", "false", "no", "off")


def _default_foreground() -> bool:
    # Allow explicit override
    if _env_bool("CCB_ASK_BACKGROUND", False):
        return False
    if _env_bool("CCB_ASK_FOREGROUND", False):
        return True
    # If CCB_CALLER is set, use background (nohup) mode
    if os.environ.get("CCB_CALLER"):
        return False
    # No caller set, use foreground mode
    return True


def _default_caller() -> str:
    caller = (os.environ.get("CCB_CALLER") or "").strip()
    if caller:
        return caller
    if _env_bool("CCB_MANAGED", False):
        return "codex"
    if os.environ.get("CODEX_SESSION_ID") or os.environ.get("CODEX_RUNTIME_DIR"):
        return "codex"
    return "claude"


def make_task_id() -> str:
    """Generate task ID: YYYYMMDD-HHMMSS-mmm-PID"""
    now = datetime.now()
    ms = now.microsecond // 1000
    return f"{now.strftime('%Y%m%d-%H%M%S')}-{ms:03d}-{os.getpid()}"


def _usage() -> None:
    print("Usage: ask <provider> [options] <message>", file=sys.stderr)
    print("", file=sys.stderr)
    print("Providers:", file=sys.stderr)
    print("  codex, claude", file=sys.stderr)
    print("", file=sys.stderr)
    print("Options:", file=sys.stderr)
    print("  -h, --help              Show this help message", file=sys.stderr)
    print("  -t, --timeout SECONDS   Request timeout (default: 3600)", file=sys.stderr)
    print("  --notify                Sync send, no wait for reply (for notifications)", file=sys.stderr)
    print("  --foreground            Run in foreground (no nohup/background)", file=sys.stderr)
    print("  --background            Force background mode", file=sys.stderr)
    print("  --no-wrap               Don't wrap with CCB protocol markers", file=sys.stderr)


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        _usage()
        return EXIT_ERROR

    # First argument must be the provider
    provider = argv[1].lower()

    if provider in ("-h", "--help"):
        _usage()
        return EXIT_OK

    if provider not in PROVIDER_DAEMONS:
        print(f"[ERROR] Unknown provider: {provider}", file=sys.stderr)
        print(f"[ERROR] Available: {', '.join(PROVIDER_DAEMONS.keys())}", file=sys.stderr)
        return EXIT_ERROR

    daemon_cmd = PROVIDER_DAEMONS[provider]

    # Parse remaining arguments
    timeout: float = 3600.0
    notify_mode = False
    no_wrap = False
    foreground_mode = _default_foreground()
    parts: list[str] = []

    it = iter(argv[2:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            return EXIT_OK
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                print("[ERROR] --timeout requires a number", file=sys.stderr)
                return EXIT_ERROR
            except ValueError:
                print("[ERROR] --timeout must be a number", file=sys.stderr)
                return EXIT_ERROR
            continue
        if token == "--notify":
            notify_mode = True
            continue
        if token == "--foreground":
            foreground_mode = True
            continue
        if token == "--background":
            foreground_mode = False
            continue
        if token == "--no-wrap":
            no_wrap = True
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if not message and not sys.stdin.isatty():
        message = read_stdin_text().strip()
    if not message:
        print("[ERROR] Message cannot be empty", file=sys.stderr)
        return EXIT_ERROR

    # Use unified daemon if enabled (CCB_UNIFIED_ASKD=1)
    if _use_unified_daemon() and foreground_mode:
        caller = _default_caller()
        return _send_via_unified_daemon(provider, message, timeout, no_wrap, caller)

    # Notify mode: sync send, no wait for reply (used for hook notifications)
    if notify_mode:
        cmd = [daemon_cmd, "--sync"]
        if no_wrap:
            cmd.append("--no-wrap")
        try:
            result = subprocess.run(
                cmd,
                input=message,
                capture_output=True,
                text=True,
                timeout=10
            )
            return result.returncode
        except subprocess.TimeoutExpired:
            return EXIT_OK
        except Exception as e:
            print(f"[ERROR] {e}", file=sys.stderr)
            return EXIT_ERROR

    # Foreground mode: run provider directly (avoid background cleanup in managed envs)
    if foreground_mode:
        cmd = [daemon_cmd, "--sync", "--timeout", str(timeout)]
        if no_wrap and provider == "claude":
            cmd.append("--no-wrap")
        env = os.environ.copy()
        if not env.get("CCB_CALLER"):
            env["CCB_CALLER"] = _default_caller()
        try:
            result = subprocess.run(cmd, input=message, text=True, env=env)
            return result.returncode
        except Exception as e:
            print(f"[ERROR] {e}", file=sys.stderr)
            return EXIT_ERROR

    # Default async mode: background task via nohup, using unified askd daemon
    if _use_unified_daemon() and not _ensure_askd_running():
        print("[ERROR] Unified askd daemon not running", file=sys.stderr)
        print("[ERROR] Hint: start it with `askd` or run via `ccb` (managed mode).", file=sys.stderr)
        return EXIT_ERROR

    task_id = make_task_id()
    log_dir = Path(tempfile.gettempdir()) / "ccb-tasks"
    log_dir.mkdir(parents=True, exist_ok=True)
    # Best-effort hardening: avoid leaking prompts/replies in multi-user environments.
    try:
        os.chmod(log_dir, 0o700)
    except Exception:
        pass
    log_file = log_dir / f"ask-{provider}-{task_id}.log"
    try:
        fd = os.open(str(log_file), os.O_CREAT | os.O_TRUNC | os.O_WRONLY, 0o600)
        os.close(fd)
    except Exception:
        pass

    # Detect caller from environment or default to "claude"
    caller = _default_caller()

    # Get the path to this script for recursive call with --foreground
    ask_cmd = str(Path(__file__).resolve())
    ccb_run_dir = (os.environ.get("CCB_RUN_DIR") or "").strip()
    ccb_run_dir_sh = shlex.quote(ccb_run_dir) if ccb_run_dir else ""
    ccb_run_dir_ps = ccb_run_dir.replace("'", "''") if ccb_run_dir else ""
    work_dir = os.getcwd()
    work_dir_sh = shlex.quote(work_dir)
    work_dir_ps = work_dir.replace("'", "''")

    # Platform-specific background execution
    if os.name == "nt":
        # Windows: use PowerShell script
        DETACHED_PROCESS = 0x00000008
        CREATE_NO_WINDOW = 0x08000000
        CREATE_NEW_PROCESS_GROUP = 0x00000200

        # Write message to temp file to avoid escaping issues
        msg_file = log_dir / f"ask-{provider}-{task_id}.msg"
        msg_file.write_text(message, encoding="utf-8")
        try:
            os.chmod(msg_file, 0o600)
        except Exception:
            pass

        # Write PowerShell script - call ask --foreground to use unified daemon
        script_file = log_dir / f"ask-{provider}-{task_id}.ps1"
        script_content = f'''$ErrorActionPreference = "SilentlyContinue"
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
$env:CCB_REQ_ID = "{task_id}"
$env:CCB_CALLER = "{caller}"
$env:CCB_WORK_DIR = '{work_dir_ps}'
{f"$env:CCB_RUN_DIR = '{ccb_run_dir_ps}'" if ccb_run_dir else ''}
Get-Content -Path "{msg_file}" -Encoding UTF8 | python "{ask_cmd}" {provider} --foreground --timeout {timeout}
'''
        script_file.write_text(script_content, encoding="utf-8")
        try:
            os.chmod(script_file, 0o700)
        except Exception:
            pass

        try:
            log_handle = open(log_file, "w", encoding="utf-8")
        except Exception:
            log_handle = open(log_file, "w")

        subprocess.Popen(
            ["powershell", "-ExecutionPolicy", "Bypass", "-NoProfile", "-File", str(script_file)],
            stdin=subprocess.DEVNULL,
            stdout=log_handle,
            stderr=subprocess.STDOUT,
            creationflags=DETACHED_PROCESS | CREATE_NO_WINDOW | CREATE_NEW_PROCESS_GROUP,
        )
    else:
        # Unix: run detached; call ask --foreground to use unified daemon.
        bg_script = f'''
export CCB_REQ_ID="{task_id}"
export CCB_CALLER="{caller}"
export CCB_WORK_DIR={work_dir_sh}
{f'export CCB_RUN_DIR={ccb_run_dir_sh}' if ccb_run_dir else ''}
python3 "{ask_cmd}" {provider} --foreground --timeout {timeout} <<'ASKEOF'
{message}
ASKEOF
'''
        # Write script to temp file for nohup execution
        script_file = log_dir / f"ask-{provider}-{task_id}.sh"
        script_file.write_text(bg_script, encoding="utf-8")
        try:
            script_file.chmod(0o700)
        except Exception:
            pass

        try:
            log_handle = open(log_file, "a", encoding="utf-8")
        except Exception:
            log_handle = open(log_file, "a")

        # Detach from terminal without relying on `nohup`/shell redirection (preserves file permissions).
        subprocess.Popen(
            ["sh", str(script_file)],
            stdin=subprocess.DEVNULL,
            stdout=log_handle,
            stderr=subprocess.STDOUT,
            start_new_session=True,
            close_fds=True,
        )

    print(f"{provider.capitalize()} processing (task: {task_id}, log: {log_file})...")
    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main(sys.argv))
