#!/usr/bin/env python3
"""
cq-mounted - Check which Code Quorum providers are mounted.

A provider is "mounted" if:
1. Session file exists (.cq_config/.{provider}-session or .{provider}-session) and is active
2. Pane is reachable/alive (best-effort) - OR socket access is blocked (sandbox mode)

Usage:
    cq-mounted [CWD] [--json|--simple] [--include-inactive] [--session <name> | --all-sessions]

Examples:
    cq-mounted
    cq-mounted --simple
    cq-mounted /path/to/project --json
    cq-mounted --session feature-x --json
    cq-mounted --all-sessions --json
"""

import sys
import os
import json
import socket
import argparse
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))

from terminal import get_backend_for_session, get_pane_id_from_session
from session_scope import DEFAULT_SESSION, resolve_session_name
from session_utils import find_project_session_file

PROVIDERS = ["codex", "claude"]


def _iter_sessions(cwd: Path) -> list[str]:
    sessions: list[str] = [DEFAULT_SESSION]
    sessions_dir = cwd / ".cq_config" / "sessions"
    try:
        if not sessions_dir.is_dir():
            return sessions
        for child in sorted(sessions_dir.iterdir(), key=lambda p: p.name):
            if not child.is_dir():
                continue
            name = (child.name or "").strip()
            try:
                normalized = resolve_session_name(name, env={})
            except ValueError:
                continue
            if normalized != DEFAULT_SESSION and normalized not in sessions:
                sessions.append(normalized)
    except Exception:
        return sessions
    return sessions


def find_session_file_path(cwd: Path, provider: str, session_name: str) -> Path | None:
    """Return the provider session file path if present."""
    return find_project_session_file(cwd, f".{provider}-session", session=session_name, env=os.environ)


def session_file_is_active(path: Path) -> bool:
    """
    Determine whether a provider session file is active.

    Backwards-compatible behavior:
    - If `active` is explicitly `false`, treat it as inactive.
    - If `active` is missing/unparseable, treat it as active.
    """
    try:
        raw = path.read_text(encoding="utf-8-sig", errors="replace")
        data = json.loads(raw)
        if isinstance(data, dict) and data.get("active") is False:
            return False
    except Exception:
        return True
    return True


def read_session_data(path: Path) -> dict:
    try:
        raw = path.read_text(encoding="utf-8-sig", errors="replace")
        data = json.loads(raw)
        return data if isinstance(data, dict) else {}
    except Exception:
        return {}


def pane_alive_for_session(session_data: dict) -> bool | None:
    """
    Best-effort liveness check for a session's pane.

    Returns:
      - True: pane is alive
      - False: pane is definitively dead
      - None: unknown (missing data or cannot probe)
    """
    if not isinstance(session_data, dict) or not session_data:
        return None

    try:
        backend = get_backend_for_session(session_data)
    except Exception:
        backend = None
    if not backend:
        return None

    pane_id = get_pane_id_from_session(session_data) or session_data.get("claude_pane_id")
    pane_id = str(pane_id or "").strip()
    if not pane_id:
        return None

    try:
        alive = bool(backend.is_alive(pane_id))
        if alive:
            return True
        # If the backend couldn't probe liveness (e.g. wezterm cli list failed), treat as unknown.
        last_err = getattr(backend, "last_list_error", None)
        if last_err:
            return None
        return False
    except Exception:
        return None


def can_connect_localhost() -> bool:
    """Test if we can make localhost socket connections (sandbox check)."""
    try:
        # Try to create a socket and connect to a likely-closed port
        # If we get "Operation not permitted", we're in a sandbox
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.1)
        try:
            # Port 1 is almost certainly not listening, so we expect connection refused
            # But if we're sandboxed, we'll get permission denied
            sock.connect(("127.0.0.1", 1))
        except PermissionError:
            # Sandbox detected
            return False
        except (socket.timeout, ConnectionRefusedError, OSError):
            # Normal behavior - we can attempt connections
            return True
        finally:
            sock.close()
    except Exception:
        return True  # Assume we can connect if test fails unexpectedly


def main() -> int:
    parser = argparse.ArgumentParser(
        prog=Path(sys.argv[0]).name or "cq-mounted",
        description="Check which Code Quorum providers are mounted for a project directory.",
    )
    parser.add_argument("cwd", nargs="?", default=".", help="Project directory (default: current working directory).")
    fmt_group = parser.add_mutually_exclusive_group()
    fmt_group.add_argument("--json", action="store_true", help="Output JSON (default).")
    fmt_group.add_argument("--simple", action="store_true", help="Output providers as a space-separated list.")
    parser.add_argument(
        "--include-inactive",
        action="store_true",
        help="Include inactive sessions (active=false).",
    )
    session_group = parser.add_mutually_exclusive_group()
    session_group.add_argument(
        "--session",
        dest="session",
        default=None,
        help="Target a specific CQ session (default: $CQ_SESSION, else default).",
    )
    session_group.add_argument(
        "--all-sessions",
        action="store_true",
        help="Enumerate providers for all sessions (default + .cq_config/sessions/*).",
    )

    args = parser.parse_args()
    try:
        cwd = Path(args.cwd).expanduser()
    except Exception:
        cwd = Path(args.cwd)
    try:
        cwd = cwd.resolve(strict=False)
    except Exception:
        pass
    include_inactive = bool(args.include_inactive)
    try:
        session_name = resolve_session_name((args.session or "").strip() or None, env=os.environ)
    except ValueError as exc:
        print(f"[ERROR] Invalid --session: {exc}", file=sys.stderr)
        return 2

    # Check if we're in a sandboxed environment
    sandboxed = not can_connect_localhost()

    def _mounted_for_session(name: str) -> list[str]:
        mounted: list[str] = []
        for provider in PROVIDERS:
            session_file = find_session_file_path(cwd, provider, name)
            if not session_file:
                continue
            if (not include_inactive) and (not session_file_is_active(session_file)):
                continue

            # Session exists (and is active unless include_inactive is set).
            if sandboxed:
                # In sandbox, trust session + active flag only.
                mounted.append(provider)
                continue

            data = read_session_data(session_file)
            alive = pane_alive_for_session(data)
            if alive is False:
                continue
            mounted.append(provider)
        return mounted

    if args.all_sessions:
        sessions = _iter_sessions(cwd)
        items = [{"session": name, "mounted": _mounted_for_session(name)} for name in sessions]

        if args.simple:
            for item in items:
                name = item["session"]
                mounted = item["mounted"]
                line = f"{name}: {' '.join(mounted)}".rstrip()
                print(line)
        else:
            result = {"cwd": str(cwd), "sessions": items}
            print(json.dumps(result))
        return 0

    mounted = _mounted_for_session(session_name)

    if args.simple:
        print(" ".join(mounted))
    else:
        result = {"cwd": str(cwd), "session": session_name, "mounted": mounted}
        print(json.dumps(result))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
