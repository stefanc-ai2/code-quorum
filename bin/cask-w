#!/usr/bin/env python3
"""
cask-w - Send message to Codex and wait for reply in background
"""
from __future__ import annotations
import os
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        print("Usage: cask-w <message>", file=sys.stderr)
        return 1

    message = " ".join(argv[1:]).strip()
    if not message:
        print("‚ùå Message cannot be empty", file=sys.stderr)
        return 1

    if sys.platform == "win32":
        from compat import setup_windows_encoding
        setup_windows_encoding()

    from codex_comm import CodexCommunicator

    try:
        comm = CodexCommunicator(lazy_init=True)

        # Check session health
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            print(f"‚ùå Session error: {status}", file=sys.stderr)
            return 1

        # Send message
        from i18n import t
        print(f"üîî {t('sending_to', provider='Codex')}", flush=True)
        marker, state = comm._send_message(message)
        print("‚úÖ Message sent, waiting for reply in background...", flush=True)

        # Double fork to fully detach background process
        if hasattr(os, 'fork'):
            pid = os.fork()
            if pid > 0:
                # Parent: return immediately
                return 0
            # First child: fork again and exit
            os.setsid()
            pid2 = os.fork()
            if pid2 > 0:
                os._exit(0)  # First child exits
            # Grandchild: wait for reply silently
            try:
                sys.stdin.close()
                sys.stdout = open(os.devnull, 'w')
                sys.stderr = open(os.devnull, 'w')

                # Wait for reply (up to 5 minutes)
                message_reply, new_state = comm.log_reader.wait_for_message(state, 300.0)

                # Save reply to cache file for cpend to read
                if message_reply:
                    cache_dir = Path.home() / ".cache" / "ccb"
                    cache_dir.mkdir(parents=True, exist_ok=True)
                    reply_file = cache_dir / "codex_last_reply.txt"
                    reply_file.write_text(message_reply, encoding="utf-8")
            except Exception:
                pass
            os._exit(0)
        else:
            # Windows: no fork, wait synchronously with short timeout
            message_reply, new_state = comm.log_reader.wait_for_message(state, 30.0)
            if message_reply:
                print(f"ü§ñ {t('reply_from', provider='Codex')}")
                print(message_reply)
            else:
                print("‚è∞ Timeout waiting for reply")
            return 0

    except Exception as exc:
        print(exc, file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
