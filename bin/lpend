#!/usr/bin/env python3
"""
lpend - View latest Claude reply
"""

import json
import os
import argparse
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
setup_windows_encoding()

from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK
from claude_comm import ClaudeLogReader
from ccb_protocol import strip_trailing_markers
from pane_registry import load_registry_by_session_id, load_registry_by_claude_pane, load_registry_by_project_id
from session_utils import find_project_session_file
from askd_client import resolve_work_dir_with_registry
from providers import LASK_CLIENT_SPEC
from project_id import compute_ccb_project_id


def _debug_enabled() -> bool:
    return (os.environ.get("CCB_DEBUG") in ("1", "true", "yes")) or (os.environ.get("LPEND_DEBUG") in ("1", "true", "yes"))


def _debug(message: str) -> None:
    if not _debug_enabled():
        return
    print(f"[DEBUG] {message}", file=sys.stderr)


def _load_session_log_path(work_dir: Path, explicit_session_file: Path | None) -> tuple[Path | None, str | None]:
    session_file = explicit_session_file or find_project_session_file(work_dir, ".claude-session")
    if not session_file:
        return None, None
    try:
        with session_file.open("r", encoding="utf-8-sig", errors="replace") as f:
            data = json.load(f)
        path_str = data.get("claude_session_path")
        session_id = data.get("claude_session_id") or data.get("session_id")
        if path_str:
            return Path(path_str).expanduser(), session_id
    except Exception as exc:
        _debug(f"Failed to read .claude-session ({session_file}): {exc}")
    return None, None


def _record_project_id(record: dict) -> str:
    pid = str(record.get("ccb_project_id") or "").strip()
    if pid:
        return pid
    wd = record.get("work_dir")
    if isinstance(wd, str) and wd.strip():
        try:
            return compute_ccb_project_id(Path(wd.strip()))
        except Exception:
            return ""
    return ""


def _load_registry_log_path(current_pid: str | None) -> tuple[Path | None, dict | None]:
    session_id = (os.environ.get("CCB_SESSION_ID") or "").strip()
    if session_id:
        record = load_registry_by_session_id(session_id)
        if record and current_pid:
            record_pid = _record_project_id(record)
            if record_pid != current_pid:
                record = None
        if record:
            providers = record.get("providers") if isinstance(record.get("providers"), dict) else {}
            claude = providers.get("claude") if isinstance(providers, dict) else None
            path_str = (claude or {}).get("claude_session_path") if isinstance(claude, dict) else record.get("claude_session_path")
            if path_str:
                path = Path(path_str).expanduser()
                _debug(f"Using registry by CCB_SESSION_ID: {path}")
                return path, record

    pane_id = (os.environ.get("WEZTERM_PANE") or os.environ.get("TMUX_PANE") or "").strip()
    if pane_id:
        record = load_registry_by_claude_pane(pane_id)
        if record and current_pid:
            record_pid = _record_project_id(record)
            if record_pid != current_pid:
                record = None
        if record:
            providers = record.get("providers") if isinstance(record.get("providers"), dict) else {}
            claude = providers.get("claude") if isinstance(providers, dict) else None
            path_str = (claude or {}).get("claude_session_path") if isinstance(claude, dict) else record.get("claude_session_path")
            if path_str:
                path = Path(path_str).expanduser()
                _debug(f"Using registry by pane id: {path}")
                return path, record
    return None, None


def _parse_n(argv: list[str]) -> int:
    if len(argv) <= 1:
        return 1
    try:
        n = int(argv[1])
    except ValueError:
        return 1
    return max(1, n)


def _mtime_safe(path: Path | None) -> float:
    if not path:
        return -1.0
    try:
        return path.stat().st_mtime
    except OSError:
        return -1.0


def _claude_session_activity_mtime(session_log_path: Path | None) -> float:
    """
    Return a best-effort "activity" timestamp for a Claude session.

    Claude can write assistant replies into per-session subagent logs without
    updating the main `<session_id>.jsonl` file. To avoid choosing stale sessions
    based solely on the main file's mtime, consider subagent log mtimes too.
    """
    if not session_log_path:
        return -1.0

    best = _mtime_safe(session_log_path)
    try:
        session_dir = session_log_path.parent / session_log_path.stem
        subagents_dir = session_dir / "subagents"
        if subagents_dir.is_dir():
            for p in subagents_dir.glob("*.jsonl"):
                best = max(best, _mtime_safe(p))
    except Exception:
        # Best-effort only; fall back to main file mtime.
        return best
    return best


def _pick_newest_session_path(registry_path: Path | None, session_path: Path | None) -> Path | None:
    """
    Pick the best session log path between registry and .claude-session.

    Both sources can be stale. Prefer whichever existing file is newest on disk.
    """
    candidates = [p for p in (registry_path, session_path) if p and p.exists()]
    if not candidates:
        return registry_path or session_path
    best = max(candidates, key=_claude_session_activity_mtime)
    return best


def main(argv: list[str]) -> int:
    try:
        parser = argparse.ArgumentParser(prog="lpend", add_help=True)
        parser.add_argument("n", nargs="?", type=int, default=1, help="Show the latest N conversations")
        parser.add_argument("--raw", action="store_true", help="Do not strip protocol/harness marker lines")
        parser.add_argument("--session-file", dest="session_file", default=None, help="Path to .claude-session (or .ccb_config/.claude-session)")
        args = parser.parse_args(argv[1:])
        n = max(1, int(args.n or 1))
        raw = bool(args.raw)

        work_dir, explicit_session_file = resolve_work_dir_with_registry(
            LASK_CLIENT_SPEC,
            provider="claude",
            cli_session_file=args.session_file,
            env_session_file=os.environ.get("CCB_SESSION_FILE"),
        )

        current_pid = ""
        try:
            current_pid = compute_ccb_project_id(work_dir)
        except Exception:
            current_pid = ""

        registry_log_path, registry_record = _load_registry_log_path(current_pid)
        if not registry_log_path:
            if current_pid:
                rec = load_registry_by_project_id(current_pid, "claude")
                if rec:
                    providers = rec.get("providers") if isinstance(rec.get("providers"), dict) else {}
                    claude = providers.get("claude") if isinstance(providers, dict) else None
                    path_str = (claude or {}).get("claude_session_path") if isinstance(claude, dict) else None
                    if isinstance(path_str, str) and path_str.strip():
                        registry_log_path = Path(path_str.strip()).expanduser()
                        registry_record = rec
                        _debug(f"Using registry by ccb_project_id: {registry_log_path}")

        session_log_path, _session_id = _load_session_log_path(work_dir, explicit_session_file)
        log_path = _pick_newest_session_path(registry_log_path, session_log_path)
        if log_path:
            if registry_log_path and session_log_path and log_path == session_log_path:
                _debug(f"Preferring .claude-session over registry (newer mtime): {log_path}")
            elif registry_log_path and session_log_path and log_path == registry_log_path:
                _debug(f"Preferring registry over .claude-session (newer mtime): {log_path}")
            elif session_log_path and not registry_log_path:
                _debug(f"Using claude_session_path from .claude-session: {log_path}")

        reader = ClaudeLogReader(work_dir=work_dir)
        if log_path:
            reader.set_preferred_session(log_path)

        if n > 1:
            conversations = reader.latest_conversations(n)
            if not conversations:
                print("No reply available", file=sys.stderr)
                return EXIT_NO_REPLY
            for i, (question, reply) in enumerate(conversations):
                if question:
                    print(f"Q: {question}")
                cleaned = reply if raw else strip_trailing_markers(reply or "")
                print(f"A: {cleaned}")
                if i < len(conversations) - 1:
                    print("---")
            return EXIT_OK

        message = reader.latest_message()
        if not message:
            print("No reply available", file=sys.stderr)
            return EXIT_NO_REPLY
        print(message if raw else strip_trailing_markers(message))
        return EXIT_OK
    except Exception as exc:
        if _debug_enabled():
            import traceback

            traceback.print_exc()
        print(f"[ERROR] execution failed: {exc}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    sys.exit(main(sys.argv))
